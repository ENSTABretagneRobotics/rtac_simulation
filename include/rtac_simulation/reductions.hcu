#ifndef _DEF_RTAC_SIMULATION_REDUCTIONS_H_
#define _DEF_RTAC_SIMULATION_REDUCTIONS_H_

#include <rtac_base/types/VectorView.h>
#include <rtac_base/cuda/DeviceVector.h>

#include <rtac_simulation/utils.hcu>
#include <rtac_simulation/Target2D.h>

namespace rtac { namespace simulation {

/**
 * This class represents a generic 1D convolution kernel defined on a
 * continuous space.
 *
 * It is defined by a function which takes a real number as a parameter and a
 * support interval [xmin,xmax] (not defined as a width to let the kernel have
 * an asymmetrical support).
 *
 * The KernelFunctionT must be copyable and compatible with cuda kernels.
 */
template <typename T, class KernelFunctionT>
class ConvolutionKernel1D : public KernelFunctionT
{
    protected:

    T xmin_;
    T xmax_;

    public:

    ConvolutionKernel1D(T xmin, T xmax, const KernelFunctionT& kernelFunction) :
        KernelFunctionT(kernelFunction),
        xmin_(xmin),
        xmax_(xmax)
    {}

    RTAC_HOSTDEVICE T xmin()  const { return xmin_; }
    RTAC_HOSTDEVICE T xmax()  const { return xmax_; }
    RTAC_HOSTDEVICE T width() const { return xmax_ - xmin_; }
};

template <typename T, class KernelFunctionTx, class KernelFunctionTy>
class SeparableKernel2D
{
    public:
    
    using Kernelx = ConvolutionKernel1D<T,KernelFunctionTx>;
    using Kernely = ConvolutionKernel1D<T,KernelFunctionTy>;

    protected:

    Kernelx kx_;
    Kernely ky_;

    public:

    SeparableKernel2D(const Kernelx& kx, const Kernely& ky) : kx_(kx), ky_(ky) {}

    RTAC_HOSTDEVICE auto operator()(T x, T y) const {
        return kx_(x) * ky_(y);
    }

    RTAC_HOSTDEVICE T xmin()  const { return kx_.xmin();  }
    RTAC_HOSTDEVICE T xmax()  const { return kx_.xmax();  }
    RTAC_HOSTDEVICE T width() const { return kx_.width(); }

    RTAC_HOSTDEVICE T ymin()   const { return ky_.xmin();  }
    RTAC_HOSTDEVICE T ymax()   const { return ky_.xmax();  }
    RTAC_HOSTDEVICE T height() const { return ky_.width(); }
};

/**
 * This is the cuda kernel responsible to aggregate all insonified sample
 * generated by the simulator.
 *
 * These insonified samples are defined by a complex response and a "location".
 * (the 2D location in this case will probably be a time delay or range and a
 * bearing angle).
 */
template <typename Tin,
          typename Tout,
          typename Kernel2DT, typename OutputFunctorT,
          unsigned int BlockSize=1024>
__global__ void sparse_convolve_2d(rtac::types::VectorView<Tin>* dataBins,
                                   TargetView2D<Tout> output,
                                   Kernel2DT          kernel,
                                   OutputFunctorT     outputFunctor)
{
    // shared memory does not play well with templates
    using T = typename ScalarType<Tout>::type;
    extern __shared__ __align__(sizeof(T)) unsigned char sharedMemory[];
    T* sdata = reinterpret_cast<T*>(sharedMemory);

    cuda::Complex<T> acc{0.0f,0.0f};
    for(auto i = threadIdx.x; i < dataBins[blockIdx.x].size(); i += blockDim.x)
    {
        auto datum = dataBins[blockIdx.x][i];
        // This multiplies the datum with the point spread function evaluated
        // at the difference between the datum location and the output bin
        // location.
        acc += datum.sample()*kernel(
            datum.location()[0] - output.height_coordinate(blockIdx.x),
            datum.location()[1] - output.width_coordinate(blockIdx.y));
    }
    
    //reduction of cuda::Complex must be performed independently on real and
    //imag parts for now (issues with volatile conversion TODO:fix this)
    sdata[threadIdx.x] = acc.real();
    __syncthreads();
    cuda::device::reduce_shared<T,BlockSize,rtac::cuda::Addition>(sdata, threadIdx.x);
    if(threadIdx.x == 0)
        acc.real(sdata[0]);

    sdata[threadIdx.x] = acc.imag();
    __syncthreads();
    cuda::device::reduce_shared<T,BlockSize,rtac::cuda::Addition>(sdata, threadIdx.x);

    if(threadIdx.x == 0) {
        acc.imag(sdata[0]);
        output(blockIdx.x,blockIdx.y) = outputFunctor(acc);
    }
}

}; //namespace simulation
}; //namespace rtac

#endif //_DEF_RTAC_SIMULATION_REDUCTIONS_H_
